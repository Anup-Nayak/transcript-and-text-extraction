Lab 2: Processor Design in LogiSim This lab will be done in the digital logic simulation program Logisim.  Download the software for your machine from moodle after satisfying the Java requirement. As mentioned in the website, “Logisim is an educational tool for designing and simulating digital logic circuits. With its simple toolbar interface and simulation of circuits as you build them, it is simple enough to facilitate learning the most basic concepts related to logic circuits. With the capacity to build larger circuits from smaller subcircuits, and to draw bundles of wires with a single mouse drag, Logisim can be used (and is used) to design and simulate entire CPUs for educational purposes.” As discussed in class, we will do this incrementally. We will ﬁrst create an ALU, then a Register ﬁle and ﬁnally the single cycle Processor that we have discussed in class. Part A: [ungraded] Familiarize yourself with Logisim Complete all the steps listed in the Beginner’s Tutorial. Implement a 4 bit Ripple Carry Adder. Simulate the design for all the 4 x 4 = 16 possible input conditions and submit the log output – show at least some cases where your outputs do not match the output as discussed in class. Speciﬁcally learn how to log outputs of the simulation as also the use of the Test Vector feature. [The next parts will be expanded with more details during as we go along] You are only allowed to use Logisim’s built-in components from the following libraries for all parts of this project:  Part B: Arithmetic Logic Unit (ALU) [7 points] Updated This task is to create an ALU that supports all the operations needed by the instructions in the ISA. Please note that we treat overﬂow as RISC-V does with unsigned instructions, meaning that we ignore overﬂow. You can use Logisim built-in components: Wires, Gates, Arithmetic, Memory The ALU has 3 inputs. 
 And one output Input Name Bit Width Description A 32 Data to use for Input A in the ALU operation B 32 Data to use for Input B in the ALU operation ALUSel 4 Selects which operation the ALU should perform  (see the list of operations with corresponding switch values below) 
Output Name Bit Width Description Result 32 Result of the ALU operation OverFlow 1 Overflow die to ADD only Zero 1 Zero if ALU operation results in 0  Implement the following functions: ALUSel Value Instruction 0 add: Result	=	A	+	B 1 sll: Result	=	A	<<	B 2 slt: Result	=	(A	<	B	(signed))	?	1	:	0 3 Unused 4 xor: Result	=	A	^	B 5 srl: Result	=	(unsigned)	A	>>	B 6 or: Result	=	A	|	B 7 and: Result	=	A	&	B 8 mul: Result	=	(signed)	(A	*	B)[31:0] 9 mulh: Result	=	(signed)	(A	*	B)[63:32] 10 Unused 11 mulhu: Result	=	(A	*	B)[63:32] 12 sub: Result	=	A	-	B 13 sra: Result	=	(signed)	A	>>	B 14 Unused 15 bsel: Result	=	B  Use the names of your input and output of the adder unit exactly as speciﬁed in the Tables above viz A, B and ALUSel for inputs and Result for output. The name of ﬁle should be alu.circ. Submission: Please submit alu.circ.  Submit  a pdf document which has screen shots to show that the circuit is working.   Part C : Register File (RegFile) [6 points] Although the CPU that we discussed in class has 32 registers, you will only need implement 9 of them (speciﬁed below) to save you some repetitive work. This means your rs1, rs2, and rd signals will still be 5-bit, but we will only test you on the speciﬁed registers. Your RegFile should be able to write to or read from these registers speciﬁed in a given RISC-V instruction without abecting any other registers. There is one notable exception: your RegFile should NOT write to x0, even if an instruction tries. Remember that the zero register should ALWAYS have the value 0x0. You should NOT gate the clock at any point in your RegFile: the clock signal should ALWAYS connect directly to the clock input of the registers without passing through ANY combinational logic. Part D: Single Cycle CPU [7 points] In this part, you will be using logisim-evolution to implement a 32-bit single-cycle processor based on mini RISC-V ISA that we have deﬁned.  Part E: Pipelined CPU [10 points] In this you will be using logisim-evolution to implement a 32-bit multi [2?]-cycle processor based on our mini RISC-V ISA. 